
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gbk" />
<link rel="stylesheet" href="../../templates/newgreen/index.css"></link>
<link rel="alternate" type="application/rss+xml" title="ChinaUnix Blog RSS Feed" href="http://blog.chinaunix.net/u/rss.php?id=19742"></link>
<meta name="keywords" content="开源日志系统log4cplus - C++编程 - 灵蛇舞动">
<meta name="description" content="中国最大的IT技术博客-ChinaUnix博客：开源日志系统log4cplus - C++编程 - 灵蛇舞动">
<title>开源日志系统log4cplus - C++编程 - 灵蛇舞动</title>
</head>
<body leftmargin=0 topmargin=0 marginwidth=0 marginheight=0 style="background:#FFFFFF;background-image:url()" align="center">

<table border="0" cellspacing="0" cellpadding="0" background="/images/tophem1.gif" style="border-collapse: collapse;height:25" height="25" width="100%" align="center">
<tr> <td id="tool-bar" align="left"  nowrap>
&nbsp;
<a href="http://blog.chinaunix.net/" target="_blank">博客首页</a>
<a href="http://blog.chinaunix.net/register.php" target="_blank">注册</a>
<a href="http://bbs.chinaunix.net/forumdisplay.php?fid=51" target="_blank">建议与交流</a> 
<a href="http://blog.chinaunix.net/top/" target="_blank">排行榜</a>
<a href="" target="_blank" onclick="NewWindows('http://www.cublog.cn/addlink.php?url='+location.href+'&title='+document.title);return false;">加入友情链接</a>

</td><form id="loginForm" method="get" target="_blank" action="/search.php">
<td align="right" nowrap>
<img src="/u2/userstar.php?blogid=19742" id="starimg" border=0 alt="" width=55 height=12>
<a href="/u2/star.php?blogid=19742" id="star" onclick="NewWindows(this.href);return false;" title="给此博客推荐值">推荐</a>
<a href="/u2/complaint.php?blogid=19742" id="complaint" onclick="NewWindows(this.href);return false;" title="投诉此博客">投诉</a>

 搜索：<input type="text" name="q" size="20"> <input type="submit" value="搜索" class="button1"> <a href="/help/" >帮助</a></td>
</form></tr>

</table>
<script language="javascript">
<!--

navHover = function() {
var lis = document.getElementById("navmenu").getElementsByTagName("LI");
for (var i=0; i<lis.length; i++) {
lis[i].onmouseover=function() {
this.className+=" iehover";
}
lis[i].onmouseout=function() {
this.className=this.className.replace(new RegExp(" iehover\\b"), "");
}
}
}

function NewWindows(shref){
var xx=(window.screen.width-450)/2;
var yy=(window.screen.height-200)/2;
pp=window.open(shref,"win","menubar=no,location=no,resizable=no,scrollbars=no,status=no,left="+xx+",top="+yy+",Width=450,Height=200");
}
function $(s){return document.getElementById(s);}
//-->
</script>
<table border="0" cellspacing="0" cellpadding="0" height="143" style="border-collapse: collapse;background-image:url(http://www.cublog.cn/templates/newgreen/images/bg_top.gif);background-repeat: no-repeat" width="100%" bgcolor="#187218" align="center">
<tr><td width="360"></td><td align="center" width="500" >

<p style="line-height: 150%; margin: 5px">
 <font style="font-size:14pt" color="#FFFFFF"><b>
<p style="line-height: 150%; margin: 5px">
 <font style="font-size:14px" 
 
 color="#FFFFFF">
 
<b>
 
 
 
 灵蛇舞动 
 
 
</b>
 
 </font></p>
 </b></font></p>

</td><td width="360">
千年灵蛇，千年修行；
灵蛇舞动，气吞长空。

<iframe src="http://www.265.com/weather.htm" width="168" height="50" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" name="265"></iframe></td></tr>
<tr><td colspan="3">
<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse" bordercolor="#111111" width="980">
<tr><td></td></tr>
</table>
</td></tr>
</table>

<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse" width="100%" align="center" background="../../templates/green/images/bg_menu.gif" height="27" bgcolor="#FFFFFF">
<tr><td width="30" align="center"><img src="../../templates/green/images/img_menu_left.gif" border="0" alt="" width="26" height="29" /></td><td width="200">
<a href="http://jcodeer.cublog.cn" class="list1" target="_blank">jcodeer.cublog.cn</a>
 
</td><td align="right" style="color:#2A5200" width="750">
<ul id="navmenu"><li class="ul0"><a href="http://control.cublog.cn/" target="_blank" class="list1">管理博客</a> </li>

<li class="ul0"><a href="http://control.cublog.cn/article_new.php" target="_blank" class="list1">发表文章</a></li>
<li class="ul0"><a href="guestbook.html" class="list1">留言</a></li>
<li class="ul0"><a href="links.html" class="list1">收藏夹</a>
<ul class="ul1"><li><a href="links_13442.html"> ・ 技术网站<!-- a13442 --></a><!-- 13442 --></li>
<li><a href="links_13443.html"> ・ 软件厂商<!-- a13443 --></a><!-- 13443 --></li>
<li><a href="links_13762.html"> ・ 数学知识<!-- a13762 --></a><!-- 13762 --></li>
<li><a href="links_13792.html"> ・ 数据结构与算法<!-- a13792 --></a><!-- 13792 --></li>
<li><a href="links_13882.html"> ・  技术博客<!-- a13882 --></a><!-- 13882 --></li>
</ul>

</li>
<li class="ul0"><a href="group.html" class="list1">博客圈</a></li>
<li class="ul0"><a href="music.html" class="list1">音乐</a>
<ul class="ul1"><li><a href="music_2701.html"> ・ 为她而歌<!-- a2701 --></a><!-- 2701 --></li>
<li><a href="music_2702.html"> ・ 为我而歌<!-- a2702 --></a><!-- 2702 --></li>
<li><a href="music_2703.html"> ・ 经典乐曲<!-- a2703 --></a><!-- 2703 --></li>
</ul>

</li>
<li class="ul0"><a href="photo.html" class="list1">相册</a>
<!-- 0 -->
</li> 
 
<li class="ul0"><a href="article.html" class="list1">文章</a>
<ul class="ul1"><li><a href="article_77870.html"> ・ 生活色彩<!-- a77870 --></a><!-- 77870 --></li>
<li><a href="article_92189.html"> ・ Java编程<!-- a92189 --></a><!-- 92189 --></li>
<li><a href="article_66836.html"> ・ 网络应用<!-- a66836 --></a><!-- 66836 --></li>
<li><a href="article_66835.html"> ・ 基础知识<!-- a66835 --></a><!-- 66835 --></li>
<li><a href="article_66837.html"> ・ 界面设计<!-- a66837 --></a><!-- 66837 --></li>
<li><a href="article_66838.html"> ・ 操作系统<!-- a66838 --></a><!-- 66838 --></li>
<li><a href="article_66839.html"> ・ 面向对象<!-- a66839 --></a><!-- 66839 --></li>
<li><a href="article_66840.html"> ・ 领域模块<!-- a66840 --></a><!-- 66840 --></li>
<li><a href="article_68313.html"> ・ 应用程序<!-- a68313 --></a><!-- 68313 --></li>
<li><a href="article_68366.html"> ・ 工具优化<!-- a68366 --></a><!-- 68366 --></li>
<li><a href="article_66845.html"> ・ 编程思考<!-- a66845 --></a><!-- 66845 --></li>
<li><a href="article_66841.html"> ・ 数据库编程<!-- a66841 --></a><!-- 66841 --></li>
<li><a href="article_64678.html"> ・ 结构化编程<!-- a64678 --></a><!-- 64678 --></li>
<li><a href="article_68861.html"> ・ 函数式编程<!-- a68861 --></a><!-- 68861 --></li>
<li><a href="article_68967.html"> ・ 混合编程<!-- a68967 --></a><!-- 68967 --></li>
<li><a href="article_81735.html"> ・ C++编程<!-- a81735 --></a><!-- 81735 --></li>
<li><a href="article_81736.html"> ・ .Net编程<!-- a81736 --></a><!-- 81736 --></li>
<li><a href="article_85751.html"> ・ VBScript<!-- a85751 --></a><!-- 85751 --></li>
<li><a href="article_70741.html"> ・ 幽默故事<!-- a70741 --></a><!-- 70741 --></li>
</ul>

</li> 
<li class="ul0"><a href="index.html" class="list1">首页</a></li>
</ul>
</td>
<td width="10"></td>
</tr>
<tr><td colspan="4">
<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse" bordercolor="#111111" width="980">
<tr><td></td></tr>
</table>
</td></tr>
</table>
<script language="javascript">
function $(s){return document.getElementById(s);}
function ShowHideDiv(divid,iImg){
if($(divid).style.display == "none"){
iImg.src="../../templates/newgreen/images/dot2.gif";
$(divid).style.display = "block";
iImg.title="收起";
}else{
iImg.src="../../templates/newgreen/images/dot4.gif";
$(divid).style.display = "none";
iImg.title="展开";
}
}
navHover();
</script>
<script language="javascript" src="http://stat.it168.com/pv.js"></script>
<script>
function sendPV(){
    var pvTrack = new PvTrack();
    pvTrack.type = 10; // 频道类别ID
    pvTrack.channel = 189; // 频道ID
   
    pvTrack.pageType = 0;
    pvTrack.track();
}
window.setTimeout("sendPV()", 0);
</script>
<script language="javascript" src="http://bbs.chinaunix.net/googlepv/pv.js" type="text/javascript"></script>
<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
<tr><td height="3"></td> </tr>
</table>


<br />
<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse" bordercolor="#111111" width="90%" align="center">
<tr><td width="18" height="28"><img src="../../templates/newgreen/images/bg_art_left_top.gif" border="0" alt="" /></td><td background="../../templates/newgreen/images/bg_art_top.gif"><p style="line-height: 150%; margin: 5px"></p></td><td width="18" height="28"><img src="../../templates/newgreen/images/bg_art_right_top.gif" border="0" alt="" /></td></tr>
<tr><td width="18"  background="../../templates/newgreen/images/bg_art_left.gif"></td><td bgcolor="#F5FDEE" align="center">
<br />
<font color="#295200" style="font-size:14pt"><b>开源日志系统log4cplus</b></font>

<table border="1" cellspacing="1" cellpadding="0" style="border-collapse: collapse" bordercolor="#A5BD6B" width="100%">
<tr><td align="center">

<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse;word-wrap:break-word;" width="100%">
<tr><td align="center">
<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse;word-wrap:break-word;"  width="100%">
<tr><td >
<div id="art"  style=" margin: 15px">
log4cplus是C++编写的开源的日志系统，功能非常全面，用到自己开发的工程中会比较专业的，：），本文介绍了log4cplus基本概念，以及如何安装，配置。 <br><pre>				<br>### 简介 ###</pre><pre>log4cplus是C++编写的开源的日志系统，前身是java编写的log4j系统.受Apache Software License<br>保护。作者是Tad E. Smith。log4cplus具有线程安全、灵活、以及多粒度控制的特点，通过将信息划分<br>优先级使其可以面向程序调试、运行、测试、和维护等全生命周期； 你可以选择将信息输出到屏幕、文件、<br>NT event log、甚至是远程服务器；通过指定策略对日志进行定期备份等等。</pre><pre>&nbsp;</pre><pre>### 下载 ###</pre><pre>最新的log4cplus可以从以下网址下载 <a href="http://log4cplus.sourceforge.net/"><font color="#002c99">http://log4cplus.sourceforge.net</font></a><br>本文使用的版本为：1.0.2</pre><pre>&nbsp;</pre><pre>### 安装 ###</pre><pre>&nbsp;</pre><pre>1. linux下安装</pre><pre>tar xvzf log4cplus-x.x.x.tar.gz<br>cd log4cplus-x.x.x<br>./configure --prefix=/where/to/install<br>make<br>make install</pre><pre>这里我采用缺省安装路径：/usr/local，下文如无特别说明，均以此路径为准。</pre><pre>&nbsp;</pre><pre>2. windows下安装</pre><pre>不需要安装，有一个msvc6存放包括源代码和用例在内的开发工程（for VC6 only），使用之前请先编译<br>"log4cplus_dll class"工程生成dll，或者编译"log4cplus_static class"工程生成lib.</pre><pre>&nbsp;</pre><pre>### 使用前的配置 ###</pre><pre>1. linux下的配置</pre><pre>确保你的Makefile中包含 /usr/local/lib/liblog4cplus.a（静态库）或&nbsp; -llog4cplus（动态库）即可，<br>头文件在/usr/local/include/log4cplus目录下。对于动态库，要想正常使用，还得将库安装路径加入到<br>LD_LIBRARY_PATH 中，我一般是这样做的：以管理员身份登录，在/etc/ld.so.conf中加入安装路径，这里<br>是/usr/local/lib，然后执行ldconfig使设置生效即可。</pre><pre>2. windows下的配置</pre><pre>将"log4cplus_dll class"工程或"log4cplus_static class"工程的dsp 文件插入到你的工程中，或者直接<br>把两个工程编译生成的库以及头文件所在目录放到你的工程的搜索路径中，如果你使用静态库，请在你的工程中<br>"project/setting/C++"的preprocessor definitions中加入LOG4CPLUS_STATIC。</pre><pre>&nbsp;</pre><pre>### 构成要素介绍 ###</pre><pre>虽然功能强大，应该说log4cplus用起来还是比较复杂的，为了更好地使用它，先介绍一下它的基本要素。</pre><pre>Layouts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：布局器，控制输出消息的格式.<br>Appenders&nbsp;&nbsp;&nbsp; ：挂接器，与布局器紧密配合，将特定格式的消息输出到所挂接的设备终端<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （如屏幕，文件等等)。<br>Logger&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：记录器，保存并跟踪对象日志信息变更的实体，当你需要对一个对象进行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记录时，就需要生成一个logger。<br>Categories&nbsp;&nbsp; ：分类器，层次化（hierarchy）的结构，用于对被记录信息的分类，层次中<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每一个节点维护一个logger的所有信息。<br>Priorities&nbsp;&nbsp; ：优先权，包括TRACE, DEBUG, INFO, WARNING, ERROR, FATAL。</pre><pre>				<br>本文介绍了log4cplus基本概念，以及如何安装，配置，下一篇将通过例子介绍如何使用log4cplus。</pre><pre>&nbsp;</pre><pre><div class="postText"><pre>本文介绍了使用log4cplus有六个步骤，并提供了一些例子引导你了解log4cplus的基本使用。</pre><br><pre>				<br>### 基本使用 ###</pre><pre>使用log4cplus有六个基本步骤：</pre><pre>1. 实例化一个appender对象<br>2. 实例化一个layout对象<br>3. 将layout对象绑定(attach)到appender对象<br>4. 实例化一个logger对象,调用静态函数：log4cplus::Logger::getInstance("logger_name")<br>5. 将appender对象绑定(attach)到logger对象，如省略此步骤，标准输出（屏幕）appender对象会绑定到logger<br>6. 设置logger的优先级，如省略此步骤，各种有限级的消息都将被记录</pre><pre>下面通过一些例子来了解log4cplus的基本使用。</pre><pre>〖例1〗<br><pre>/*<br>&nbsp;&nbsp;&nbsp; 严格实现步骤1-6，appender输出到屏幕, 其中的布局格式和LogLevel后面会详细解释。<br>*/<br>#include &lt;log4cplus/logger.h&gt;<br>#include &lt;log4cplus/consoleappender.h&gt;<br>#include &lt;log4cplus/layout.h&gt;<log4cplus></log4cplus></pre><pre>using namespace log4cplus;<br>using namespace log4cplus::helpers;</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; /* step 1: Instantiate an appender object */<br>&nbsp;&nbsp;&nbsp; SharedObjectPtr<appender> _append (new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("append for test");</appender></pre><pre>&nbsp;&nbsp;&nbsp; /* step 2: Instantiate a layout object */<br>&nbsp;&nbsp;&nbsp; std::string pattern = "%d{%m/%d/%y %H:%M:%S}&nbsp; - %m [%l]%n";<br>&nbsp;&nbsp;&nbsp; std::auto_ptr<layout> _layout(new PatternLayout(pattern));</layout></pre><pre>&nbsp;&nbsp;&nbsp; /* step 3: Attach the layout object to the appender */<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout( _layout );</pre><pre>&nbsp;&nbsp;&nbsp; /* step 4: Instantiate a logger object */<br>&nbsp;&nbsp;&nbsp; Logger _logger = Logger::getInstance("test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 5: Attach the appender object to the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.addAppender(_append);</pre><pre>&nbsp;&nbsp;&nbsp; /* step 6: Set a priority for the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.setLogLevel(ALL_LOG_LEVEL);</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; /* log activity */<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "This is the FIRST log message...")<br>&nbsp;&nbsp;&nbsp; sleep(1);<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_WARN(_logger, "This is the SECOND log message...")</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><br></pre><pre>输出结果：<br>10/14/04 09:06:24&nbsp; - This is the FIRST log message... [main.cpp:31]<br>10/14/04 09:06:25&nbsp; - This is the SECOND log message... [main.cpp:33]</pre><pre>				<br>〖例2〗<br>/*<br>&nbsp;&nbsp;&nbsp; 简洁使用模式，appender输出到屏幕。<br>*/<br>#include &lt;log4cplus/logger.h&gt;<br>#include &lt;log4cplus/consoleappender.h&gt;<log4cplus></log4cplus></pre><pre>using namespace log4cplus;<br>using namespace log4cplus::helpers;</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; /* step 1: Instantiate an appender object */<br>&nbsp;&nbsp;&nbsp; SharedAppenderPtr _append(new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("append test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 4: Instantiate a logger object */<br>&nbsp;&nbsp;&nbsp; Logger _logger = Logger::getInstance("test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 5: Attach the appender object to the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.addAppender(_append);</pre><pre>&nbsp;&nbsp;&nbsp; /* log activity */<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "This is the FIRST log message...")<br>&nbsp;&nbsp;&nbsp; sleep(1);<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_WARN(_logger, "This is the SECOND log message...")</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>输出结果：<br>DEBUG - This is the FIRST log message...<br>WARN - This is the SECOND log message...</pre><pre>				<br>〖例3〗<br>/*<br>&nbsp;&nbsp;&nbsp; iostream模式，appender输出到屏幕。<br>*/<br>#include &lt;log4cplus/logger.h&gt;<br>#include &lt;log4cplus/consoleappender.h&gt;<br>#include &lt;iomanip&gt; /* 其实这个东东还是放到log4cplus头文件中比较合适些，个人意见：） */using namespace log4cplus;</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; /* step 1: Instantiate an appender object */<br>&nbsp;&nbsp;&nbsp; SharedAppenderPtr _append(new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("append test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 4: Instantiate a logger object */<br>&nbsp;&nbsp;&nbsp; Logger _logger = Logger::getInstance("test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 5: Attach the appender object to the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.addAppender(_append);</pre><pre>&nbsp;&nbsp;&nbsp; /* log activity */<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_TRACE(_logger, "This is"&nbsp; &lt;&lt; " just a t" &lt;&lt; "est." &lt;&lt; std::endl)<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "This is a bool: " &lt;&lt; true)<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_INFO(_logger, "This is a char: " &lt;&lt; 'x')<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_WARN(_logger, "This is a int: " &lt;&lt; 1000)<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_ERROR(_logger, "This is a long(hex): " &lt;&lt; std::hex &lt;&lt; 100000000)<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(_logger, "This is a double: "&nbsp; &lt;&lt; std::setprecision(15)&nbsp; &lt;&lt; 1.2345234234)</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>输出结果：<br>DEBUG - This is a bool: 1<br>INFO - This is a char: x<br>WARN - This is a int: 1000<br>ERROR - This is a long(hex): 5f5e100<br>FATAL - This is a double: 1.2345234234</pre><pre>				<br>〖例4〗<br>/*<br>&nbsp;&nbsp;&nbsp; 调试模式，通过loglog来控制输出调试、警告或错误信息，appender输出到屏幕。<br>*/<br>#include &lt;iostream&gt;<br>#include &lt;log4cplus/helpers/loglog.h&gt;</pre><pre>using namespace log4cplus::helpers;</pre><pre>void printMsgs(void)<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Entering printMsgs()..." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; LogLog::getLogLog()-&gt;debug("This is a Debug statement...");<br>&nbsp;&nbsp;&nbsp; LogLog::getLogLog()-&gt;warn("This is a Warning...");<br>&nbsp;&nbsp;&nbsp; LogLog::getLogLog()-&gt;error("This is a Error...");<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Exiting printMsgs()..." &lt;&lt; std::endl &lt;&lt; std::endl;<br>}</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; /*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LogLog类实现了debug, warn, error 函数用于输出调试、警告或错误信息，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同时提供了两个方法来进一步控制所输出的信息，其中：</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setInternalDebugging方法用来控制是否屏蔽输出信息中的调试信息，当输入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数为false则屏蔽，缺省设置为false。</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setQuietMode方法用来控制是否屏蔽所有输出信息，当输入参数为true则屏蔽，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缺省设置为false。</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LogLog::getLogLog()-&gt;setInternalDebugging(false);<br>&nbsp;&nbsp;&nbsp; */</pre><pre>&nbsp;&nbsp;&nbsp; printMsgs();</pre><pre>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Turning on debug..." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; LogLog::getLogLog()-&gt;setInternalDebugging(true);<br>&nbsp;&nbsp;&nbsp; printMsgs();</pre><pre>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Turning on quiet mode..." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; LogLog::getLogLog()-&gt;setQuietMode(true);<br>&nbsp;&nbsp;&nbsp; printMsgs();</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>输出结果：<br>Entering printMsgs()...<br>log4cplus:WARN This is a Warning...<br>log4cplus:ERROR This is a Error...<br>Exiting printMsgs()...</pre><pre>Turning on debug...<br>Entering printMsgs()...<br>log4cplus: This is a Debug statement...<br>log4cplus:WARN This is a Warning...<br>log4cplus:ERROR This is a Error...<br>Exiting printMsgs()...</pre><pre>Turning on quiet mode...<br>Entering printMsgs()...<br>Exiting printMsgs()...</pre><pre>需要指出的是，输出信息中总是包含"log4cplus:"前缀，有时候会感觉不爽，这是因为LogLog在实现时候死定了要这么写：</pre><pre>LogLog::LogLog()<br>&nbsp;: mutex(LOG4CPLUS_MUTEX_CREATE),<br>&nbsp;&nbsp; debugEnabled(false),<br>&nbsp;&nbsp; quietMode(false),<br>&nbsp;&nbsp; PREFIX( LOG4CPLUS_TEXT("log4cplus: ") ),<br>&nbsp;&nbsp; WARN_PREFIX( LOG4CPLUS_TEXT("log4cplus:WARN ") ),<br>&nbsp;&nbsp; ERR_PREFIX( LOG4CPLUS_TEXT("log4cplus:ERROR ") )<br>{<br>}</pre><pre>你可以把这些前缀换成自己看着爽的提示符号，然后重新编译，hihi。除非万不得已或者实在郁闷的不行，否则还是不要这样干。</pre><pre>				<br>〖例5〗<br><div style="border: 1px solid rgb(204, 204, 204); padding: 4px 5px 4px 4px; font-size: 13px; width: 98%; background-color: rgb(238, 238, 238);"><span style="color: rgb(0, 128, 0);">/*</span><span style="color: rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp;&nbsp;文件模式，appender输出到文件。</span><span style="color: rgb(0, 128, 0);">*/<br></span><span style="color: rgb(0, 0, 0);">#include&nbsp;</span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);">log4cplus</span><span style="color: rgb(0, 0, 0);">/</span><span style="color: rgb(0, 0, 0);">logger.h</span><span style="color: rgb(0, 0, 0);">&gt;<br></span><span style="color: rgb(0, 0, 0);">#include&nbsp;</span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);">log4cplus</span><span style="color: rgb(0, 0, 0);">/</span><span style="color: rgb(0, 0, 0);">fileappender.h</span><span style="color: rgb(0, 0, 0);">&gt;</span><span style="color: rgb(0, 0, 0);"><br></span><span style="color: rgb(0, 0, 255);">using</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 255);">namespace</span><span style="color: rgb(0, 0, 0);">&nbsp;log4cplus;<br></span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;main()<br>{&nbsp;&nbsp;&nbsp;&nbsp;<br></span><span style="color: rgb(0, 128, 0);">/*</span><span style="color: rgb(0, 128, 0);">&nbsp;step&nbsp;1:&nbsp;Instantiate&nbsp;an&nbsp;appender&nbsp;object&nbsp;</span><span style="color: rgb(0, 128, 0);">*/<br></span><span style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;SharedAppenderPtr&nbsp;_append(</span><span style="color: rgb(0, 0, 255);">new</span><span style="color: rgb(0, 0, 0);">&nbsp;FileAppender(</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">Test.log</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">));<br>&nbsp;&nbsp;&nbsp;&nbsp;_append</span><span style="color: rgb(0, 0, 0);">-&gt;</span><span style="color: rgb(0, 0, 0);">setName(</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">file&nbsp;log&nbsp;test</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">);<br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0, 128, 0);">/*</span><span style="color: rgb(0, 128, 0);">&nbsp;step&nbsp;4:&nbsp;Instantiate&nbsp;a&nbsp;logger&nbsp;object&nbsp;</span><span style="color: rgb(0, 128, 0);">*/<br></span><span style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;Logger&nbsp;_logger&nbsp;</span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);">&nbsp;Logger::getInstance(</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">test.subtestof_filelog</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">);<br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0, 128, 0);">/*</span><span style="color: rgb(0, 128, 0);">&nbsp;step&nbsp;5:&nbsp;Attach&nbsp;the&nbsp;appender&nbsp;object&nbsp;to&nbsp;the&nbsp;logger&nbsp;&nbsp;</span><span style="color: rgb(0, 128, 0);">*/<br></span><span style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;_logger.addAppender(_append);<br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0, 128, 0);">/*</span><span style="color: rgb(0, 128, 0);">&nbsp;log&nbsp;activity&nbsp;</span><span style="color: rgb(0, 128, 0);">*/<br></span><span style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);">(&nbsp;i&nbsp;</span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">;&nbsp;i&nbsp;</span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">5</span><span style="color: rgb(0, 0, 0);">;&nbsp;</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">i&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG4CPLUS_DEBUG(_logger,&nbsp;</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">Entering&nbsp;loop&nbsp;#</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">&lt;&lt;</span><span style="color: rgb(0, 0, 0);">&nbsp;i&nbsp;</span><span style="color: rgb(0, 0, 0);">&lt;&lt;</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">End&nbsp;line&nbsp;#</span><span style="color: rgb(0, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0, 0, 255);">return</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">;<br>}<br></span></div></pre><pre>输出结果（Test.log文件）：</pre><pre>DEBUG - Entering loop #0End line #<br>DEBUG - Entering loop #1End line #<br>DEBUG - Entering loop #2End line #<br>DEBUG - Entering loop #3End line #<br>DEBUG - Entering loop #4End line #</pre><pre>&nbsp;</pre><pre><div class="postText"><p>本文介绍了三种控制输出格式的布局管理器的概念和使用情况，通过掌握这些知识，可以更有效地控制log系统输出尽可能贴近你需求的信息来。<br></p><pre>				<br>### 如何控制输出消息的格式 ###</pre><pre>前面已经讲过，log4cplus通过布局器（Layouts）来控制输出的格式，log4cplus提供了三种类型的Layouts，<br>分别是SimpleLayout、PatternLayout、和TTCCLayout。其中：</pre><pre>1. SimpleLayout<br>是一种简单格式的布局器，在输出的原始信息之前加上LogLevel和一个"-"。</pre><pre>比如以下代码片段：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...</pre><pre>&nbsp;&nbsp;&nbsp; /* step 1: Instantiate an appender object */<br>&nbsp;&nbsp;&nbsp; SharedObjectPtr _append (new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("append for test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 2: Instantiate a layout object */<br>&nbsp;&nbsp;&nbsp; std::auto_ptr&nbsp; _layout(new log4cplus::SimpleLayout());</pre><pre>&nbsp;&nbsp;&nbsp; /* step 3: Attach the layout object to the appender */<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout( _layout );</pre><pre>&nbsp;&nbsp;&nbsp; /* step 4: Instantiate a logger object */<br>&nbsp;&nbsp;&nbsp; Logger _logger = Logger::getInstance("test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 5: Attach the appender object to the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.addAppender(_append);</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; /* log activity */<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "This is the simple formatted log message...")<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>将打印结果：<br>DEBUG - This is the simple formatted log message...</pre><pre>2. PatternLayout<br>是一种有词法分析功能的模式布局器，一提起模式就会想起正则表达式，这里的模式和正则表达式类似，但是<br>远比后者简单，能够对预定义的标识符（称为conversion specifiers）进行解析，转换成特定格式输出。以下<br>代码片段演示了如何使用PatternLayout：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...</pre><pre>&nbsp;&nbsp;&nbsp; /* step 1: Instantiate an appender object */<br>&nbsp;&nbsp;&nbsp; SharedObjectPtr _append (new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("append for test");<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; /* step 2: Instantiate a layout object */<br>&nbsp;&nbsp;&nbsp; std::string pattern = "%d{%m/%d/%y %H:%M:%S}&nbsp; - %m [%l]%n";<br>&nbsp;&nbsp;&nbsp; std::auto_ptr _layout(new PatternLayout(pattern));<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; /* step 3: Attach the layout object to the appender */<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout( _layout );</pre><pre>&nbsp;&nbsp;&nbsp; /* step 4: Instantiate a logger object */<br>&nbsp;&nbsp;&nbsp; Logger _logger = Logger::getInstance("test_logger.subtest");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 5: Attach the appender object to the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.addAppender(_append);</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; /* log activity */<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "teststr")<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>输出结果：<br>10/16/04 18:51:25&nbsp; - teststr [main.cpp:51]</pre><pre>可以看出通过填写特定格式的模式字符串"pattern"，原始信息被包含到一堆有格式的信息当中了，这就使得<br>用户可以根据自身需要来定制显示内容。"pattern"可以包含普通字符串和预定义的标识符，其中：</pre><pre>（1）普通字符串，能够被直接显示的信息。<br>（2）预定义标识符，通过"%"与一个或多个字符共同构成预定义的标识符，能够产生出特定格式信息。</pre><pre>关于预定义标识符，log4cplus文档中提供了详细的格式说明，我每种都试了一下，以上述代码为例，根据不同<br>的pattern，各种消息格式使用情况列举如下：</pre><pre>（1）"%%"，转义为%, 即，std::string pattern = "%%" 时输出: "%"<br>（2）"%c"，输出logger名称，比如std::string pattern ="%c" 时输出: "test_logger.subtest"，<br>&nbsp;&nbsp;&nbsp;&nbsp; 也可以控制logger名称的显示层次，比如"%c{1}"时输出"test_logger"，其中数字表示层次。<br>（3）"%D"，显示本地时间，当std::string pattern ="%D" 时输出:"2004-10-16 18:55:45"，%d显示标准时间，<br>&nbsp;&nbsp;&nbsp;&nbsp; 所以当std::string pattern ="%d" 时输出 "2004-10-16 10:55:45" （因为我们是东8区，差8个小时啊）。<br>&nbsp;&nbsp;&nbsp;&nbsp; 可以通过%d{...}定义更详细的显示格式，比如%d{%H:%M:%s}表示要显示小时:分钟：秒。大括号中可显示的<br>&nbsp;&nbsp;&nbsp;&nbsp; 预定义标识符如下：<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>%a -- 表示礼拜几，英文缩写形式，比如"Fri"<br>%A -- 表示礼拜几，比如"Friday"<br>%b -- 表示几月份，英文缩写形式，比如"Oct"<br>%B -- 表示几月份，"October"<br>%c -- 标准的日期＋时间格式，如 "Sat Oct 16 18:56:19 2004"<br>%d -- 表示今天是这个月的几号(1-31)"16"<br>%H -- 表示当前时刻是几时(0-23)，如 "18"<br>%I -- 表示当前时刻是几时(1-12)，如 "6"<br>%j -- 表示今天是哪一天(1-366)，如 "290"<br>%m -- 表示本月是哪一月(1-12)，如 "10"<br>%M -- 表示当前时刻是哪一分钟(0-59)，如 "59"<br>%p -- 表示现在是上午还是下午， AM or PM<br>%q -- 表示当前时刻中毫秒部分(0-999)，如 "237"<br>%Q -- 表示当前时刻中带小数的毫秒部分(0-999.999)，如 "430.732"<br>%S -- 表示当前时刻的多少秒(0-59)，如 "32"<br>%U -- 表示本周是今年的第几个礼拜，以周日为第一天开始计算(0-53)，如 "41"<br>%w -- 表示礼拜几，(0-6, 礼拜天为0)，如 "6"<br>%W -- 表示本周是今年的第几个礼拜，以周一为第一天开始计算(0-53)，如 "41"<br>%x -- 标准的日期格式，如 "10/16/04"<br>%X -- 标准的时间格式，如 "19:02:34"<br>%y -- 两位数的年份(0-99)，如 "04"<br>%Y -- 四位数的年份，如 "2004"<br>%Z -- 时区名，比如 "GMT"</pre><pre>（4）"%F"，输出当前记录器所在的文件名称，比如std::string pattern ="%F" 时输出: "main.cpp"<br>（5）"%L"，输出当前记录器所在的文件行号，比如std::string pattern ="%L" 时输出: "51"<br>（6）"%l"，输出当前记录器所在的文件名称和行号，比如std::string pattern ="%L" 时输出:<br>&nbsp;&nbsp;&nbsp;&nbsp; "main.cpp:51"<br>（7）"%m"，输出原始信息，比如std::string pattern ="%m" 时输出: "teststr"，即上述代码中<br>&nbsp;&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG的第二个参数，这种实现机制可以确保原始信息被嵌入到带格式的信息中。<br>（8）"%n"，换行符，没什么好解释的<br>（9）"%p"，输出LogLevel，比如std::string pattern ="%p" 时输出: "DEBUG"<br>（10）"%t"，输出记录器所在的线程ID，比如std::string pattern ="%t" 时输出: "1075298944"<br>（11）"%x"，嵌套诊断上下文NDC (nested diagnostic context) 输出，从堆栈中弹出上下文信息，NDC可以用对<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不同源的log信息（同时地）交叉输出进行区分，关于NDC方面的详细介绍会在下文中提到。<br>（12）格式对齐，比如std::string pattern ="%-10m"时表示左对齐，宽度是10，此时会输出"teststr&nbsp;&nbsp; "，当<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然其它的控制字符也可以相同的方式来使用，比如"%-12d"，"%-5p"等等（刚接触log4cplus文档时还以为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%-5p"整个字符串代表LogLevel呢，呵呵）。</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>3. TTCCLayout<br>是在PatternLayout基础上发展的一种缺省的带格式输出的布局器， 其格式由时间，线程ID，Logger和NDC 组<br>成（consists of time, thread, Logger and nested diagnostic context information, hence the name），<br>因而得名（怎么得名的？Logger里哪里有那个"C"的缩写啊！名字起得真够烂的，想扁人）。提供给那些想显示<br>典型的信息（一般情况下够用了）又懒得配置pattern的同志们。</pre><pre>TTCCLayout在构造时有机会选择显示本地时间或GMT时间，缺省是按照本地时间显示：<br>TTCCLayout::TTCCLayout(bool use_gmtime&nbsp; = false)</pre><pre>以下代码片段演示了如何使用TTCCLayout：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...</pre><pre>&nbsp;&nbsp;&nbsp; /* step 1: Instantiate an appender object */<br>&nbsp;&nbsp;&nbsp; SharedObjectPtr _append (new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("append for test");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 2: Instantiate a layout object */<br>&nbsp;&nbsp;&nbsp; std::auto_ptr _layout(new TTCCLayout());</pre><pre>&nbsp;&nbsp;&nbsp; /* step 3: Attach the layout object to the appender */<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout( _layout );</pre><pre>&nbsp;&nbsp;&nbsp; /* step 4: Instantiate a logger object */<br>&nbsp;&nbsp;&nbsp; Logger _logger = Logger::getInstance("test_logger");</pre><pre>&nbsp;&nbsp;&nbsp; /* step 5: Attach the appender object to the logger&nbsp; */<br>&nbsp;&nbsp;&nbsp; _logger.addAppender(_append);</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; /* log activity */<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "teststr")<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>输出结果：<br>10-16-04 19:08:27,501 [1075298944] DEBUG test_logger &lt;&gt; - teststr</pre><pre>				<br>当构造TTCCLayout对象时选择GMT时间格式时：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; /* step 2: Instantiate a layout object */<br>&nbsp;&nbsp;&nbsp; std::auto_ptr _layout(new TTCCLayout(true));<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>输出结果：<br>10-16-04 11:12:47,678 [1075298944] DEBUG test_logger &lt;&gt; - teststr</pre><pre>				<br>本文介绍了控制log信息格式的相关知识，下一部分将详细介绍log信息的几种文件操作方式。</pre><pre>&nbsp;</pre><pre><div class="postText"><p>将log信息记录到文件应该说是日志系统的一个基本功能，log4cplus在此基础上，提供了更多的功能，可以按照你预先设定的大小来决定是否转储，当超过该大小，后续log信息会另存到新文件中，依次类推；或者按照日期来决定是否转储。本文将详细介绍这些用法。</p><br><pre>				<br>### 如何将log记录到文件 ###</pre><pre>我们在例5中给出了一个将log记录到文件的例子，用的是FileAppender类实现的，log4cplus提供了三个类用于<br>文件操作，它们是FileAppender类、RollingFileAppender类、DailyRollingFileAppender类。</pre><pre>1. FileAppender类</pre><pre>实现了基本的文件操作功能，构造函数如下：</pre><pre>FileAppender(const log4cplus::tstring&amp; filename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG4CPLUS_OPEN_MODE_TYPE mode = LOG4CPLUS_FSTREAM_NAMESPACE::ios::trunc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool immediateFlush = true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 文件名<br>mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 文件类型，可选择的文件类型包括app、ate、binary、in、out、trunc，因为实际上只是对<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl的一个简单包装，呵呵，这里就不多讲了。缺省是trunc，表示将先前文件删除。<br>immediateFlush ：缓冲刷新标志，如果为true表示每向文件写一条记录就刷新一次缓存，否则直到FileAppender<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 被关闭或文件缓存已满才更新文件，一般是要设置true的，比如你往文件写的过程中出现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 了错误（如程序非正常退出），即使文件没有正常关闭也可以保证程序终止时刻之前的所有<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记录都会被正常保存。</pre><pre>FileAppender类的使用情况请参考例5，这里不再赘述。</pre><pre>				<br>2. RollingFileAppender类</pre><pre>构造函数如下：<br>log4cplus::RollingFileAppender::RollingFileAppender(const log4cplus::tstring&amp; filename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long maxFileSize,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int maxBackupIndex,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool immediateFlush)</pre><pre>filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 文件名<br>maxFileSize&nbsp;&nbsp;&nbsp; : 文件的最大尺寸<br>maxBackupIndex : 最大记录文件数<br>immediateFlush : 缓冲刷新标志<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>RollingFileAppender类可以根据你预先设定的大小来决定是否转储，当超过该大小，后续log信息会另存到新<br>文件中，除了定义每个记录文件的大小之外，你还要确定在RollingFileAppender类对象构造时最多需要多少个<br>这样的记录文件(maxBackupIndex+1)，当存储的文件数目超过maxBackupIndex+1时，会删除最早生成的文件，<br>保证整个文件数目等于maxBackupIndex+1。然后继续记录，比如以下代码片段：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; #define LOOP_COUNT 200000<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; SharedAppenderPtr _append(new RollingFileAppender("Test.log", 5*1024, 5));<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("file test");<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout( std::auto_ptr<layout>(new TTCCLayout()) );<br>&nbsp;&nbsp;&nbsp; Logger::getRoot().addAppender(_append);</layout></pre><pre>&nbsp;&nbsp;&nbsp; Logger root = Logger::getRoot();<br>&nbsp;&nbsp;&nbsp; Logger test = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; Logger subTest = Logger::getInstance("test.subtest");</pre><pre>&nbsp;&nbsp;&nbsp; for(int i=0; i<loop_count;>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDCContextCreator _context("loop");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(subTest, "Entering loop #" &lt;&lt; i)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; </loop_count;></pre><pre>运行结果：</pre><pre>运行后会产生6个输出文件，Test.log、Test.log.1、Test.log.2、Test.log.3、Test.log.4、Test.log.5<br>其中Test.log存放着最新写入的信息，而最后一个文件中并不包含第一个写入信息，说明已经被不断更新了。<br>需要指出的是，这里除了Test.log之外，每个文件的大小都是200K,而不是我们想像中的5K，这是因为<br>log4cplus中隐含定义了文件的最小尺寸是200K，只有大于200K的设置才生效，&lt;= 200k的设置都会被认为是<br>200K.</pre><pre>				<br>3. DailyRollingFileAppender类</pre><pre>构造函数如下：<br>DailyRollingFileAppender::DailyRollingFileAppender(const log4cplus::tstring&amp; filename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DailyRollingFileSchedule schedule,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool immediateFlush,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int maxBackupIndex)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 文件名<br>schedule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 存储频度<br>immediateFlush : 缓冲刷新标志<br>maxBackupIndex : 最大记录文件数</pre><pre>DailyRollingFileAppender类可以根据你预先设定的频度来决定是否转储，当超过该频度，后续log信息会另存<br>到新文件中，这里的频度包括：MONTHLY（每月）、WEEKLY（每周）、DAILY（每日）、TWICE_DAILY（每两天）、<br>HOURLY（每时）、MINUTELY（每分）。maxBackupIndex的含义同上所述，比如以下代码片段：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; SharedAppenderPtr _append(new DailyRollingFileAppender("Test.log", MINUTELY, true, 5));<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("file test");<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout( std::auto_ptr<layout>(new TTCCLayout()) );<br>&nbsp;&nbsp;&nbsp; Logger::getRoot().addAppender(_append);</layout></pre><pre>&nbsp;&nbsp;&nbsp; Logger root = Logger::getRoot();<br>&nbsp;&nbsp;&nbsp; Logger test = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; Logger subTest = Logger::getInstance("test.subtest");</pre><pre>&nbsp;&nbsp;&nbsp; for(int i=0; i<loop_count;>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDCContextCreator _context("loop");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(subTest, "Entering loop #" &lt;&lt; i)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...</loop_count;></pre><pre>				<br>运行结果：</pre><pre>运行后会以分钟为单位，分别生成名为Test.log.2004-10-17-03-03、Test.log.2004-10-17-03-04和<br>Test.log.2004-10-17-03-05这样的文件。</pre><pre>需要指出的是，刚看到按照频度（如HOURLY、MINUTELY）转储这样的概念，以为log4cplus提供了内部定时器，<br>感觉很奇怪，因为日志系统不应该主动记录，而loging事件总是应该被动触发的啊。仔细看了源代码后才知道<br>这里的"频度"并不是你写入文件的速度，其实是否转储的标准并不依赖你写入文件的速度，而是依赖于写入<br>的那一时刻是否满足了频度条件，即是否超过了以分钟、小时、周、月为单位的时间刻度，如果超过了就另存。</pre><pre>本部分详细介绍log信息的几种文件操作方式，下面将重点介绍一下如何有选择地控制log信息的输出。</pre><pre>&nbsp;</pre><pre><div class="postText"><pre>日志系统的另一个基本功能就是能够让使用者按照自己的意愿来控制什么时候，哪些log信息可以输出。<br>如果能够让用户在任意时刻设置允许输出的LogLevel的信息就好了，log4cplus通过LogLevelManager、<br>LogLog、Filter三种方式实现了上述功能。</pre><br><pre>				<br>### 优先级控制 ###</pre><pre>在研究LogLevelManager之前，首先介绍一下log4cplus中logger的存储机制，在log4cplus中，所有<br>logger都通过一个层次化的结构（其实内部是hash表）来组织的，有一个Root级别的logger,可以通<br>过以下方法获取：</pre><pre>&nbsp;&nbsp;&nbsp; Logger root = Logger::getRoot();<br>&nbsp;&nbsp;&nbsp; <br>用户定义的logger都有一个名字与之对应，比如：</pre><pre>&nbsp;&nbsp;&nbsp; Logger test = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; <br>可以定义该logger的子logger:</pre><pre>&nbsp;&nbsp;&nbsp; Logger subTest = Logger::getInstance("test.subtest");<br>&nbsp;&nbsp;&nbsp; <br>注意Root级别的logger只有通过getRoot方法获取，Logger::getInstance("root")获得的是它的<br>子对象而已。有了这些具有父子关系的logger之后可分别设置其LogLevel,比如：</pre><pre>root.setLogLevel( ... );<br>Test.setLogLevel( ... );<br>subTest.setLogLevel( ... );</pre><pre>				<br>logger的这种父子关联性会体现在优先级控制方面，log4cplus将输出的log信息按照LogLevel<br>（从低到高）分为：</pre><pre>NOT_SET_LOG_LEVEL (&nbsp;&nbsp; -1) ：接受缺省的LogLevel，如果有父logger则继承它的LogLevel<br>ALL_LOG_LEVEL&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp; 0) ：开放所有log信息输出<br>TRACE_LOG_LEVEL&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp; 0) ：开放trace信息输出(即ALL_LOG_LEVEL)<br>DEBUG_LOG_LEVEL&nbsp;&nbsp; (10000) ：开放debug信息输出<br>INFO_LOG_LEVEL&nbsp;&nbsp;&nbsp; (20000) ：开放info信息输出<br>WARN_LOG_LEVEL&nbsp;&nbsp;&nbsp; (30000) ：开放warning信息输出<br>ERROR_LOG_LEVEL&nbsp;&nbsp; (40000) ：开放error信息输出<br>FATAL_LOG_LEVEL&nbsp;&nbsp; (50000) ：开放fatal信息输出<br>OFF_LOG_LEVEL&nbsp;&nbsp;&nbsp;&nbsp; (60000) ：关闭所有log信息输出</pre><pre>LogLevelManager负责设置logger的优先级，各个logger可以通过setLogLevel设置自己的优先级，<br>当某个logger的LogLevel设置成NOT_SET_LOG_LEVEL时，该logger会继承父logger的优先级，另外，<br>如果定义了重名的多个logger, 对其中任何一个的修改都会同时改变其它logger,我们举例说明：</pre><pre>〖例6〗</pre><pre>#include "log4cplus/logger.h"<br>#include "log4cplus/consoleappender.h"<br>#include "log4cplus/loglevel.h"<br>#include &lt;iostream&gt;<iostream></iostream></pre><pre>using namespace std;<br>using namespace log4cplus;</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; SharedAppenderPtr _append(new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("test");<br>&nbsp;&nbsp;&nbsp; Logger::getRoot().addAppender(_append);<br>&nbsp;&nbsp;&nbsp; Logger root = Logger::getRoot();</pre><pre>&nbsp;&nbsp;&nbsp; Logger test = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; Logger subTest = Logger::getInstance("test.subtest");<br>&nbsp;&nbsp;&nbsp; LogLevelManager&amp; llm = getLogLevelManager();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Before Setting, Default LogLevel" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "root: " &lt;&lt; llm.toString(root.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test: " &lt;&lt; llm.toString(test.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test.subtest: " &lt;&lt; llm.toString(subTest.getChainedLogLevel()))</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Setting test.subtest to WARN" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; subTest.setLogLevel(WARN_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "root: " &lt;&lt; llm.toString(root.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test: " &lt;&lt; llm.toString(test.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test.subtest: " &lt;&lt; llm.toString(subTest.getChainedLogLevel()))</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Setting test.subtest to TRACE" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; test.setLogLevel(TRACE_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "root: " &lt;&lt; llm.toString(root.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test: " &lt;&lt; llm.toString(test.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test.subtest: " &lt;&lt; llm.toString(subTest.getChainedLogLevel()))</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Setting test.subtest to NO_LEVEL" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; subTest.setLogLevel(NOT_SET_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "root: " &lt;&lt; llm.toString(root.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test: " &lt;&lt; llm.toString(test.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test.subtest: " &lt;&lt; llm.toString(subTest.getChainedLogLevel()) &lt;&lt; '\n')</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "create a logger test_bak, named \"test_\", too. " &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; Logger test_bak = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Setting test to INFO, so test_bak also be set to INFO" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; test.setLogLevel(INFO_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test: " &lt;&lt; llm.toString(test.getChainedLogLevel()))<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(root, "test_bak: " &lt;&lt; llm.toString(test_bak.getChainedLogLevel()))</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>输出结果：</pre><pre>Before Setting, Default LogLevel<br>FATAL - root: DEBUG<br>FATAL - test: DEBUG<br>FATAL - test.subtest: DEBUG</pre><pre>Setting test.subtest to WARN<br>FATAL - root: DEBUG<br>FATAL - test: DEBUG<br>FATAL - test.subtest: WARN</pre><pre>Setting test.subtest to TRACE<br>FATAL - root: DEBUG<br>FATAL - test: TRACE<br>FATAL - test.subtest: WARN</pre><pre>Setting test.subtest to NO_LEVEL<br>FATAL - root: DEBUG<br>FATAL - test: TRACE<br>FATAL - test.subtest: TRACE</pre><pre>create a logger test_bak, named "test_", too.<br>Setting test to INFO, so test_bak also be set to INFO<br>FATAL - test: INFO<br>FATAL - test_bak: INFO</pre><pre>				<br>下面的例子演示了如何通过设置LogLevel来控制用户的log信息输出：</pre><pre>〖例7〗</pre><pre>#include "log4cplus/logger.h"<br>#include "log4cplus/consoleappender.h"<br>#include "log4cplus/loglevel.h"<br>#include &lt;iostream&gt;<iostream></iostream></pre><pre>using namespace std;<br>using namespace log4cplus;</pre><pre>void ShowMsg(void)<br>{<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_TRACE(Logger::getRoot(),"info")<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(Logger::getRoot(),"info")<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_INFO(Logger::getRoot(),"info")<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_WARN(Logger::getRoot(),"info")<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_ERROR(Logger::getRoot(),"info")<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(Logger::getRoot(),"info")<br>}</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; SharedAppenderPtr _append(new ConsoleAppender());<br>&nbsp;&nbsp;&nbsp; _append-&gt;setName("test");<br>&nbsp;&nbsp;&nbsp; _append-&gt;setLayout(std::auto_ptr<layout>(new TTCCLayout()));<br>&nbsp;&nbsp;&nbsp; Logger root = Logger::getRoot();<br>&nbsp;&nbsp;&nbsp; root.addAppender(_append);</layout></pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "all-log allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(ALL_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "trace-log and above allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(TRACE_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "debug-log and above allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(DEBUG_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "info-log and above allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(INFO_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "warn-log and above allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(WARN_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "error-log and above allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(ERROR_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "fatal-log and above allowed" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(FATAL_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "log disabled" &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp; root.setLogLevel(OFF_LOG_LEVEL);<br>&nbsp;&nbsp;&nbsp; ShowMsg();</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>输出结果：</pre><pre>all-log allowed<br>10-17-04 10:11:40,587 [1075298944] TRACE root &lt;&gt; - info<br>10-17-04 10:11:40,590 [1075298944] DEBUG root &lt;&gt; - info<br>10-17-04 10:11:40,591 [1075298944] INFO root &lt;&gt; - info<br>10-17-04 10:11:40,591 [1075298944] WARN root &lt;&gt; - info<br>10-17-04 10:11:40,592 [1075298944] ERROR root &lt;&gt; - info<br>10-17-04 10:11:40,592 [1075298944] FATAL root &lt;&gt; - info</pre><pre>trace-log and above allowed<br>10-17-04 10:11:40,593 [1075298944] TRACE root &lt;&gt; - info<br>10-17-04 10:11:40,593 [1075298944] DEBUG root &lt;&gt; - info<br>10-17-04 10:11:40,594 [1075298944] INFO root &lt;&gt; - info<br>10-17-04 10:11:40,594 [1075298944] WARN root &lt;&gt; - info<br>10-17-04 10:11:40,594 [1075298944] ERROR root &lt;&gt; - info<br>10-17-04 10:11:40,594 [1075298944] FATAL root &lt;&gt; - info</pre><pre>debug-log and above allowed<br>10-17-04 10:11:40,595 [1075298944] DEBUG root &lt;&gt; - info<br>10-17-04 10:11:40,595 [1075298944] INFO root &lt;&gt; - info<br>10-17-04 10:11:40,596 [1075298944] WARN root &lt;&gt; - info<br>10-17-04 10:11:40,596 [1075298944] ERROR root &lt;&gt; - info<br>10-17-04 10:11:40,596 [1075298944] FATAL root &lt;&gt; - info</pre><pre>info-log and above allowed<br>10-17-04 10:11:40,597 [1075298944] INFO root &lt;&gt; - info<br>10-17-04 10:11:40,597 [1075298944] WARN root &lt;&gt; - info<br>10-17-04 10:11:40,597 [1075298944] ERROR root &lt;&gt; - info<br>10-17-04 10:11:40,598 [1075298944] FATAL root &lt;&gt; - info</pre><pre>warn-log and above allowed<br>10-17-04 10:11:40,598 [1075298944] WARN root &lt;&gt; - info<br>10-17-04 10:11:40,598 [1075298944] ERROR root &lt;&gt; - info<br>10-17-04 10:11:40,599 [1075298944] FATAL root &lt;&gt; - info</pre><pre>error-log and above allowed<br>10-17-04 10:11:40,599 [1075298944] ERROR root &lt;&gt; - info<br>10-17-04 10:11:40,600 [1075298944] FATAL root &lt;&gt; - info</pre><pre>fatal-log and above allowed<br>10-17-04 10:11:40,600 [1075298944] FATAL root &lt;&gt; - info</pre><pre>log disabled</pre><pre>&nbsp;</pre><pre>用户也可以自行定义LogLevel，操作比较简单，首先要定义LEVEL值，比如HELLO_LOG_LEVEL定义如下：</pre><pre>/* DEBUG_LOG_LEVEL&nbsp; &lt; HELLO_LOG_LEVEL &lt; INFO_LOG_LEVEL */<br>const LogLevel HELLO_LOG_LEVEL = 15000;</pre><pre>然后定义以下宏即可：</pre><pre>/* define MACRO LOG4CPLUS_HELLO */<br>#define LOG4CPLUS_HELLO(logger, logEvent) \<br>&nbsp;&nbsp;&nbsp; if(logger.isEnabledFor(HELLO_LOG_LEVEL)) { \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log4cplus::tostringstream _log4cplus_buf; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _log4cplus_buf &lt;&lt; logEvent; \<br>&nbsp;logger.forcedLog(HELLO_LOG_LEVEL, _log4cplus_buf.str(), __FILE__, __LINE__); \<br>&nbsp;&nbsp;&nbsp; }</pre><pre>不过log4cplus没有提供给用户一个接口来实现LEVEL值与字符串的转换，所以当带格式输出LogLevel字符<br>串时候会显示"UNKNOWN"， 不够理想。比如用TTCCLayout控制输出的结果可能会如下所示：</pre><pre>10-17-04 11:17:51,124 [1075298944] UNKNOWN root &lt;&gt; - info</pre><pre>而不是期望的以下结果：<br>10-17-04 11:17:51,124 [1075298944] HELLO root &lt;&gt; - info</pre><pre>要想实现第二种结果，按照log4cplus现有的接口机制，只能改其源代码后重新编译，方法是在loglevel.cxx<br>中加入：</pre><pre>#define _HELLO_STRING LOG4CPLUS_TEXT("HELLO")</pre><pre>然后修改log4cplus::tstring&nbsp; defaultLogLevelToStringMethod(LogLevel ll)函数，增加一个判断：</pre><pre>case HELLO_LOG_LEVEL:&nbsp;&nbsp;&nbsp; return _HELLO_STRING;</pre><pre>重新编译log4cplus源代码后生成库文件，再使用时即可实现满意效果。</pre><pre>				<br>### 调试模式 ###</pre><pre>即通过loglog来控制输出调试、警告或错误信息，见例4，这里不再赘述。</pre><pre>&nbsp;</pre><pre>### 基于脚本配置来过滤log信息 ###</pre><pre>除了通过程序实现对log环境的配置之外，log4cplus通过PropertyConfigurator类实现了基于脚本配置的功能。<br>通过脚本可以完成对logger、appender和layout的配置，因此可以解决怎样输出，输出到哪里的问题，我将在<br>全文的最后一部分中提到多线程环境中如何利用脚本配置来配合实现性能测试，本节将重点介绍基脚本实现过<br>滤log信息的功能。</pre><pre>首先简单介绍一下脚本的语法规则：</pre><pre>包括Appender的配置语法和logger的配置语法，其中：</pre><pre>1.Appender的配置语法:</pre><pre>（1）设置名称：</pre><pre>/*设置方法*/<br>log4cplus.appender.appenderName=fully.qualified.name.of.appender.class</pre><pre>例如（列举了所有可能的Appender，其中SocketAppender后面会讲到）：<br>log4cplus.appender.append_1=log4cplus::ConsoleAppender<br>log4cplus.appender.append_2=log4cplus::FileAppender<br>log4cplus.appender.append_3=log4cplus::RollingFileAppender<br>log4cplus.appender.append_4=log4cplus::DailyRollingFileAppender<br>log4cplus.appender.append_4=log4cplus::SocketAppender</pre><pre>（2）设置Filter：</pre><pre>包括选择过滤器和设置过滤条件，可选择的过滤器包括：LogLevelMatchFilter、LogLevelRangeFilter、<br>和StringMatchFilter：</pre><pre>对LogLevelMatchFilter来说，过滤条件包括LogLevelToMatch和AcceptOnMatch（true|false）， 只有<br>当log信息的LogLevel值与LogLevelToMatch相同，且AcceptOnMatch为true时才会匹配。</pre><pre>LogLevelRangeFilter来说，过滤条件包括LogLevelMin、LogLevelMax和AcceptOnMatch，只有当log信息<br>的LogLevel在LogLevelMin、LogLevelMax之间同时AcceptOnMatch为true时才会匹配。</pre><pre>对StringMatchFilter来说，过滤条件包括StringToMatch和AcceptOnMatch，只有当log信息的LogLevel值<br>与StringToMatch对应的LogLevel值与相同， 且AcceptOnMatch为true时会匹配。</pre><pre>				<br>过滤条件处理机制类似于IPTABLE的Responsibility chain，（即先deny、再allow）不过执行顺序刚好相反，<br>后写的条件会被先执行，比如：</pre><pre>log4cplus.appender.append_1.filters.1=log4cplus::spi::LogLevelMatchFilter<br>log4cplus.appender.append_1.filters.1.LogLevelToMatch=TRACE<br>log4cplus.appender.append_1.filters.1.AcceptOnMatch=true<br>#log4cplus.appender.append_1.filters.2=log4cplus::spi::DenyAllFilter</pre><pre>会首先执行filters.2的过滤条件，关闭所有过滤器，然后执行filters.1，仅匹配TRACE信息。</pre><pre>（3）设置Layout</pre><pre>可以选择不设置、TTCCLayout、或PatternLayout</pre><pre>如果不设置，会输出简单格式的log信息。</pre><pre>设置TTCCLayout如下所示：<br>log4cplus.appender.ALL_MSGS.layout=log4cplus::TTCCLayout</pre><pre>设置PatternLayout如下所示：<br>log4cplus.appender.append_1.layout=log4cplus::PatternLayout<br>log4cplus.appender.append_1.layout.ConversionPattern=%d{%m/%d/%y %H:%M:%S,%Q} [%t] %-5p - %m%n</pre><pre>				<br>2.logger的配置语法</pre><pre>包括rootLogger和non-root logger。</pre><pre>对于rootLogger来说：<br>log4cplus.rootLogger=[LogLevel], appenderName, appenderName, ...</pre><pre>对于non-root logger来说：<br>log4cplus.logger.logger_name=[LogLevel|INHERITED], appenderName, appenderName, ...</pre><pre>				<br>脚本方式使用起来非常简单，只要首先加载配置即可（urconfig.properties是自行定义的配置文件）：</pre><pre>PropertyConfigurator::doConfigure("urconfig.properties");</pre><pre>				<br>下面我们通过例子体会一下log4cplus强大的基于脚本过滤log信息的功能。</pre><pre>				<br>〖例8〗</pre><pre>/*<br>&nbsp;*&nbsp;&nbsp;&nbsp; urconfig.properties<br>&nbsp;*/<br>log4cplus.rootLogger=TRACE, ALL_MSGS, TRACE_MSGS, DEBUG_INFO_MSGS, FATAL_MSGS</pre><pre>log4cplus.appender.ALL_MSGS=log4cplus::RollingFileAppender<br>log4cplus.appender.ALL_MSGS.File=all_msgs.log<br>log4cplus.appender.ALL_MSGS.layout=log4cplus::TTCCLayout</pre><pre>log4cplus.appender.TRACE_MSGS=log4cplus::RollingFileAppender<br>log4cplus.appender.TRACE_MSGS.File=trace_msgs.log<br>log4cplus.appender.TRACE_MSGS.layout=log4cplus::TTCCLayout<br>log4cplus.appender.TRACE_MSGS.filters.1=log4cplus::spi::LogLevelMatchFilter<br>log4cplus.appender.TRACE_MSGS.filters.1.LogLevelToMatch=TRACE<br>log4cplus.appender.TRACE_MSGS.filters.1.AcceptOnMatch=true<br>log4cplus.appender.TRACE_MSGS.filters.2=log4cplus::spi::DenyAllFilter</pre><pre>log4cplus.appender.DEBUG_INFO_MSGS=log4cplus::RollingFileAppender<br>log4cplus.appender.DEBUG_INFO_MSGS.File=debug_info_msgs.log<br>log4cplus.appender.DEBUG_INFO_MSGS.layout=log4cplus::TTCCLayout<br>log4cplus.appender.DEBUG_INFO_MSGS.filters.1=log4cplus::spi::LogLevelRangeFilter<br>log4cplus.appender.DEBUG_INFO_MSGS.filters.1.LogLevelMin=DEBUG<br>log4cplus.appender.DEBUG_INFO_MSGS.filters.1.LogLevelMax=INFO<br>log4cplus.appender.DEBUG_INFO_MSGS.filters.1.AcceptOnMatch=true<br>log4cplus.appender.DEBUG_INFO_MSGS.filters.2=log4cplus::spi::DenyAllFilter</pre><pre>log4cplus.appender.FATAL_MSGS=log4cplus::RollingFileAppender<br>log4cplus.appender.FATAL_MSGS.File=fatal_msgs.log<br>log4cplus.appender.FATAL_MSGS.layout=log4cplus::TTCCLayout<br>log4cplus.appender.FATAL_MSGS.filters.1=log4cplus::spi::StringMatchFilter<br>log4cplus.appender.FATAL_MSGS.filters.1.StringToMatch=FATAL<br>log4cplus.appender.FATAL_MSGS.filters.1.AcceptOnMatch=true<br>log4cplus.appender.FATAL_MSGS.filters.2=log4cplus::spi::DenyAllFilter</pre><pre>				<br>/*<br>&nbsp;*&nbsp;&nbsp;&nbsp; main.cpp<br>&nbsp;*/<br>#include &lt;log4cplus/logger.h&gt;<br>#include &lt;log4cplus/configurator.h&gt;<br>#include &lt;log4cplus/helpers/stringhelper.h&gt;<log4cplus></log4cplus></pre><pre>using namespace log4cplus;</pre><pre>static Logger logger = Logger::getInstance("log");</pre><pre>void printDebug()<br>{<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_TRACE_METHOD(logger, "::printDebug()");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(logger, "This is a DEBUG message");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_INFO(logger, "This is a INFO message");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_WARN(logger, "This is a WARN message");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_ERROR(logger, "This is a ERROR message");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_FATAL(logger, "This is a FATAL message");<br>}<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; Logger root = Logger::getRoot();<br>&nbsp;&nbsp;&nbsp; PropertyConfigurator::doConfigure("urconfig.properties");<br>&nbsp;&nbsp;&nbsp; printDebug();</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>运行结果：</pre><pre>1. all_msgs.log<br>10-17-04 14:55:25,858 [1075298944] TRACE log &lt;&gt; - ENTER: ::printDebug()<br>10-17-04 14:55:25,871 [1075298944] DEBUG log &lt;&gt; - This is a DEBUG message<br>10-17-04 14:55:25,873 [1075298944] INFO log &lt;&gt; - This is a INFO message<br>10-17-04 14:55:25,873 [1075298944] WARN log &lt;&gt; - This is a WARN message<br>10-17-04 14:55:25,874 [1075298944] ERROR log &lt;&gt; - This is a ERROR message<br>10-17-04 14:55:25,874 [1075298944] FATAL log &lt;&gt; - This is a FATAL message<br>10-17-04 14:55:25,875 [1075298944] TRACE log &lt;&gt; - EXIT:&nbsp; ::printDebug()</pre><pre>2. trace_msgs.log<br>10-17-04 14:55:25,858 [1075298944] TRACE log &lt;&gt; - ENTER: ::printDebug()<br>10-17-04 14:55:25,875 [1075298944] TRACE log &lt;&gt; - EXIT:&nbsp; ::printDebug()</pre><pre>3. debug_info_msgs.log<br>10-17-04 14:55:25,871 [1075298944] DEBUG log &lt;&gt; - This is a DEBUG message<br>10-17-04 14:55:25,873 [1075298944] INFO log &lt;&gt; - This is a INFO message</pre><pre>4. fatal_msgs.log<br>10-17-04 14:55:25,874 [1075298944] FATAL log &lt;&gt; - This is a FATAL message</pre><pre>&nbsp;</pre><pre>本部分详细介绍了如何有选择地控制log信息的输出，最后一部分我们将介绍一下多线程、<br>和C/S模式下该如何操作，顺便提一下NDC的概念。</pre><pre>&nbsp;</pre><pre><div class="postText"><p>log4cplus在很多方面做的都很出色，但是使用过程有些地方感觉不爽。在继续吹捧之前我先把不爽之处<br>稍微提一提，然后继续介绍关于线程和套接字的知识。<br></p><pre>### 一些可以改进之处 ###</pre><pre>1. 用户自定义LogLevel的实现机制不够开放</pre><pre>在第五篇中曾经介绍过如何实现用户自行定义LogLevel，为了实现比较理想的效果，甚至还需要改log4cplus<br>的源代码。：（</pre><pre>2. 生成Logger对象的机制可以改进</pre><pre>我在使用时候，经常需要在不同的文件、函数中操作同一个logger，虽然log4cplus实现了树状存储以及根据<br>名称生成Logger，却没有充分利用这样的特点确保同一个名称对应的logger对象的唯一性，比如以下代码：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Logger logger1 = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; Logger logger2 = Logger::getInstance("test");</pre><pre>&nbsp;&nbsp;&nbsp; Logger * plogger1 = &amp;logger1;<br>&nbsp;&nbsp;&nbsp; Logger * plogger2 = &amp;logger2;</pre><pre>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "plogger1: " &lt;&lt; plogger1 &lt;&lt; std::endl &lt;&lt; "plogger2: " &lt;&lt; plogger2 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>运行结果：</pre><pre>plogger1: 0xbfffe5a0<br>plogger2: 0xbfffe580</pre><pre>				<br>从结果可以看出，明明是同一个Logger，但每次调用都会产生一个Logger副本，虽然结果是正确的（因为将存<br>储和操作分开了），但是资源有些浪费，我看了一下log4cplus的代码，其实可以按照如下方式实现（示意性<br>的）：</pre><pre>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;map&gt;<map></map></pre><pre>/* forward declaration */<br>class Logger;</pre><pre>class LoggerContainer<br>{<br>public:</pre><pre>&nbsp;&nbsp;&nbsp; ~LoggerContainer();</pre><pre>&nbsp;&nbsp;&nbsp; Logger * getinstance(const std::string &amp; strLogger);</pre><pre>private:</pre><pre>&nbsp;&nbsp;&nbsp; typedef std::map&lt;:string,&gt; LoggerMap;<br>&nbsp;&nbsp;&nbsp; LoggerMap loggerPtrs;<br>};</pre><pre>class Logger<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp; Logger() {std::cout &lt;&lt; "ctor of Logger " &lt;&lt; std::endl; }<br>&nbsp;&nbsp;&nbsp; ~Logger() {std::cout &lt;&lt; "dtor of Logger " &lt;&lt; std::endl; }</pre><pre>&nbsp;&nbsp;&nbsp; static Logger * getInstance( const std::string &amp; strLogger)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static LoggerContainer defaultLoggerContainer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return defaultLoggerContainer.getinstance(strLogger);<br>&nbsp;&nbsp;&nbsp; }<br>};</pre><pre>LoggerContainer::~LoggerContainer()<br>{<br>&nbsp;&nbsp;&nbsp; /* release all ptr in LoggerMap */<br>&nbsp;&nbsp;&nbsp; LoggerMap::iterator itr = loggerPtrs.begin();</pre><pre>&nbsp;&nbsp;&nbsp; for( ; itr != loggerPtrs.end(); ++itr )<br>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp; delete (*itr).second;<br>&nbsp;}</pre><pre>}</pre><pre>Logger * LoggerContainer::getinstance(const std::string &amp; strLogger)<br>{<br>&nbsp;&nbsp; LoggerMap::iterator itr = loggerPtrs.find(strLogger);</pre><pre>&nbsp;&nbsp; if(itr != loggerPtrs.end())<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* logger exist, just return it */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*itr).second;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* return a new logger */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logger * plogger = new Logger();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loggerPtrs.insert(std::make_pair(strLogger, plogger));</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return plogger;<br>&nbsp;&nbsp; }<br>}</pre><pre>int main()<br>{<br>&nbsp;&nbsp;&nbsp; Logger * plogger1 = Logger::getInstance("test");<br>&nbsp;&nbsp;&nbsp; Logger * plogger2 = Logger::getInstance("test");</pre><pre>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "plogger1: " &lt;&lt; plogger1 &lt;&lt; std::endl &lt;&lt; "plogger2: " &lt;&lt; plogger2 &lt;&lt; std::endl;</pre><pre>&nbsp;&nbsp;&nbsp; return 0;<br>}</pre><pre>				<br>运行结果：</pre><pre>ctor of Logger<br>plogger1: 0x804fc30<br>plogger2: 0x804fc30<br>dtor of Logger</pre><pre>这里的LoggerContainer相当于log4cplus中的Hierarchy类，结果可以看出，通过同一个名称可以获取相同的<br>Logger实例。</pre><pre>				<br>还有一些小毛病比如RollingFileAppender和DailyRollingFileAppender的参数输入顺序可以调整成统一方式<br>等等，就不细说了。</pre><pre>本部分提到了使用log4cplus时候感觉不爽的地方，最后一部分将介绍一下log4cplus中线程和套接字实现情况<br></pre><pre>&nbsp;</pre><pre><div class="postText"><p>经过短暂的熟悉过程，log4cplus已经被成功应用到了我的项目中去了，效果还不错，：）除了上文提及的<br>功能之外，下面将介绍log4cplus提供的线程和套接字的使用情况。<br></p><pre>### NDC ###</pre><pre>首先我们先了解一下log4cplus中嵌入诊断上下文（Nested Diagnostic Context），即NDC。对log系统而言，<br>当输入源可能不止一个，而只有一个输出时，往往需要分辩所要输出消息的来源，比如服务器处理来自不同<br>客户端的消息时就需要作此判断，NDC可以为交错显示的信息打上一个标记(stamp)， 使得辨认工作看起来<br>比较容易些，呵呵。这个标记是线程特有的，利用了线程局部存储机制，称为线程私有数据（Thread-specific<br>&nbsp;Data，或TSD）。 看了一下源代码，相关定义如下，包括定义、初始化、获取、设置和清除操作：</pre><pre>linux pthread</pre><pre>				<br>#&nbsp;&nbsp; define LOG4CPLUS_THREAD_LOCAL_TYPE pthread_key_t*<br>#&nbsp;&nbsp; define LOG4CPLUS_THREAD_LOCAL_INIT ::log4cplus::thread::createPthreadKey()<br>#&nbsp;&nbsp; define LOG4CPLUS_GET_THREAD_LOCAL_VALUE( key ) pthread_getspecific(*key)<br>#&nbsp;&nbsp; define LOG4CPLUS_SET_THREAD_LOCAL_VALUE( key, value ) pthread_setspecific(*key, value)<br>#&nbsp;&nbsp; define LOG4CPLUS_THREAD_LOCAL_CLEANUP( key ) pthread_key_delete(*key)</pre><pre>win32</pre><pre>#&nbsp;&nbsp; define LOG4CPLUS_THREAD_LOCAL_TYPE DWORD<br>#&nbsp;&nbsp; define LOG4CPLUS_THREAD_LOCAL_INIT TlsAlloc()<br>#&nbsp;&nbsp; define LOG4CPLUS_GET_THREAD_LOCAL_VALUE( key ) TlsGetValue(key)<br>#&nbsp;&nbsp; define LOG4CPLUS_SET_THREAD_LOCAL_VALUE( key, value ) \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TlsSetValue(key, static_cast<lpvoid>(value))<br>#&nbsp;&nbsp; define LOG4CPLUS_THREAD_LOCAL_CLEANUP( key ) TlsFree(key)</lpvoid></pre><pre>				<br>使用起来比较简单，在某个线程中：</pre><pre>&nbsp;&nbsp;&nbsp; NDC&amp; ndc = log4cplus::getNDC();<br>&nbsp;&nbsp;&nbsp; ndc.push("ur ndc string");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(logger, "this is a NDC test");</pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ndc.pop();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(logger, "There should be no NDC...");<br>&nbsp;&nbsp;&nbsp; ndc.remove();<br>&nbsp;&nbsp;&nbsp; <br>当设定输出格式(Layout)为TTCCLayout时，输出如下：</pre><pre>10-21-04 21:32:58, [3392] DEBUG test <ur string="" ndc=""> - this is a NDC test<br>10-21-04 21:32:58, [3392] DEBUG test &lt;&gt; - There should be no NDC...</ur></pre><pre>也可以在自定义的输出格式中使用NDC(用%x) ，比如：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string pattern = "NDC:[%x]&nbsp; - %m %n";<br>&nbsp;&nbsp;&nbsp; std::auto_ptr<layout> _layout(new PatternLayout(pattern));</layout></pre><pre>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(_logger, "This is the FIRST log message...")<br>&nbsp;&nbsp;&nbsp; NDC&amp; ndc = log4cplus::getNDC();<br>&nbsp;&nbsp;&nbsp; ndc.push("ur ndc string");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_WARN(_logger, "This is the SECOND log message...")<br>&nbsp;&nbsp;&nbsp; ndc.pop();<br>&nbsp;&nbsp;&nbsp; ndc.remove();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; <br>输出如下：</pre><pre>NDC:[]&nbsp; - This is the FIRST log message...<br>NDC:[ur ndc string]&nbsp; - This is the SECOND log message...</pre><pre>				<br>另外一种更简单的使用方法是在线程中直接用NDCContextCreator：</pre><pre>&nbsp;&nbsp;&nbsp; NDCContextCreator _first_ndc("ur ndc string");<br>&nbsp;&nbsp;&nbsp; LOG4CPLUS_DEBUG(logger, "this is a NDC test")<br>&nbsp;&nbsp;&nbsp; <br>不必显式地调用push/pop了，而且当出现异常时，能够确保push与pop的调用是匹配的。</pre><pre>&nbsp;&nbsp;&nbsp; <br>### 线程 ###</pre><pre>线程是log4cplus中的副产品， 而且仅作了最基本的实现，使用起来也异常简单，只要且必须要<br>在派生类中重载run函数即可：</pre><pre>class TestThread : public AbstractThread<br>{<br>public:</pre><pre>&nbsp;&nbsp;&nbsp; virtual void run();</pre><pre>};</pre><pre>				<br>void TestThread::run()<br>{<br>&nbsp;&nbsp;&nbsp; /* do sth. */<br>&nbsp;&nbsp;&nbsp; ... ...</pre><pre>}</pre><pre>log4cplus的线程没有考虑同步、死锁，有互斥，实现线程切换的小函数挺别致的：</pre><pre>void log4cplus::thread::yield()<br>{<br>#if defined(LOG4CPLUS_USE_PTHREADS)<br>&nbsp;&nbsp;&nbsp; ::sched_yield();<br>#elif defined(LOG4CPLUS_USE_WIN32_THREADS)<br>&nbsp;&nbsp;&nbsp; ::Sleep(0);<br>#endif<br>}</pre><pre>				<br>### 套接字 ###</pre><pre>套接字也是log4cplus中的副产品，在namespace log4cplus::helpers中，实现了C/S方式的日志记录。</pre><pre>1. 客户端程序需要做的工作：</pre><pre>/* 定义一个SocketAppender类型的挂接器 */<br>SharedAppenderPtr _append(new SocketAppender(host, 8888, "ServerName"));</pre><pre>/* 把_append加入到logger中 */<br>Logger::getRoot().addAppender(_append);</pre><pre>/*&nbsp; SocketAppender类型不需要Layout, 直接调用宏就可以将信息发往loggerServer了 */<br>LOG4CPLUS_INFO(Logger::getRoot(), "This is a test: ")</pre><pre>				<br>【注】 这里对宏的调用其实是调用了SocketAppender::append，里面有一个数据传输约定，即先发送<br>一个后续数据的总长度，然后再发送实际的数据：</pre><pre>&nbsp;&nbsp;&nbsp; ... ...</pre><pre>&nbsp;&nbsp;&nbsp; SocketBuffer buffer = convertToBuffer(event, serverName);<br>&nbsp;&nbsp;&nbsp; SocketBuffer msgBuffer(LOG4CPLUS_MAX_MESSAGE_SIZE);</pre><pre>&nbsp;&nbsp;&nbsp; msgBuffer.appendSize_t(buffer.getSize());<br>&nbsp;&nbsp;&nbsp; msgBuffer.appendBuffer(buffer);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ... ...</pre><pre>				<br>2. 服务器端程序需要做的工作：</pre><pre>/* 定义一个ServerSocket */<br>ServerSocket serverSocket(port);</pre><pre>&nbsp;</pre><pre>/* 调用accept函数创建一个新的socket与客户端连接 */<br>Socket sock = serverSocket.accept();</pre><pre>				<br>此后即可用该sock进行数据read/write了,形如：</pre><pre>SocketBuffer msgSizeBuffer(sizeof(unsigned int));</pre><pre>if(!clientsock.read(msgSizeBuffer))<br>{<br>&nbsp;&nbsp;&nbsp; return;<br>}</pre><pre>unsigned int msgSize = msgSizeBuffer.readInt();</pre><pre>SocketBuffer buffer(msgSize);</pre><pre>if(!clientsock.read(buffer))<br>{<br>&nbsp;&nbsp;&nbsp; return;<br>}</pre><pre>为了将读到的数据正常显示出来，需要将SocketBuffer存放的内容转换成InternalLoggingEvent格式：</pre><pre>spi::InternalLoggingEvent event = readFromBuffer(buffer);</pre><pre>然后输出：<br>Logger logger = Logger::getInstance(event.getLoggerName());<br>logger.callAppenders(event);</pre><pre>				<br>【注】 read/write是按照阻塞方式实现的，意味着对其调用直到满足了所接收或发送的个数才返回。</pre></div></pre></div></pre></div></pre></div></pre></div></pre></div></pre>
		
		
		<table style="border-collapse: collapse; width: 554px; height: 812px;" bgcolor="#f1f1f1" border="1" bordercolor="#999999" cellpadding="0" cellspacing="0"><tbody><tr><td><p style="margin: 5px; line-height: 150%;"><code><span style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 153, 0);">/*<br>
&nbsp;&nbsp;&nbsp;&nbsp;严格实现步骤1-6，appender输出到屏幕, 其中的布局格式和LogLevel后面会详细解释。<br>
*/</span><br>
<span style="color: rgb(0, 0, 204);">#</span><span style="color: rgb(255, 0, 0);">include</span> <span style="color: rgb(0, 0, 204);">&lt;</span>log4cplus<span style="color: rgb(0, 0, 204);">/</span>logger<span style="color: rgb(0, 0, 204);">.</span>h<span style="color: rgb(0, 0, 204);">&gt;</span><br>
<span style="color: rgb(0, 0, 204);">#</span><span style="color: rgb(255, 0, 0);">include</span> <span style="color: rgb(0, 0, 204);">&lt;</span>log4cplus<span style="color: rgb(0, 0, 204);">/</span>consoleappender<span style="color: rgb(0, 0, 204);">.</span>h<span style="color: rgb(0, 0, 204);">&gt;</span><br>
<span style="color: rgb(0, 0, 204);">#</span><span style="color: rgb(255, 0, 0);">include</span> <span style="color: rgb(0, 0, 204);">&lt;</span>log4cplus<span style="color: rgb(0, 0, 204);">/</span>layout<span style="color: rgb(0, 0, 204);">.</span>h<span style="color: rgb(0, 0, 204);">&gt;</span><br>
<br>
<span style="color: rgb(0, 0, 255);">using</span> <span style="color: rgb(0, 0, 255);">namespace</span> log4cplus<span style="color: rgb(0, 0, 204);">;</span><br>
<span style="color: rgb(0, 0, 255);">using</span> <span style="color: rgb(0, 0, 255);">namespace</span> log4cplus<span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span>helpers<span style="color: rgb(0, 0, 204);">;</span><br>
<br>
<span style="color: rgb(0, 0, 255);">int</span> main<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 204);">)</span><br>
<span style="color: rgb(0, 0, 204);">{</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 1: Instantiate an appender object */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;SharedObjectPtr _append <span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 255);">new</span> ConsoleAppender<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_append<span style="color: rgb(0, 0, 204);">-</span><span style="color: rgb(0, 0, 204);">&gt;</span>setName<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(255, 0, 255);">"append for test"</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 2: Instantiate a layout object */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">std</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(255, 0, 0);">string</span> pattern <span style="color: rgb(0, 0, 204);">=</span> <span style="color: rgb(255, 0, 255);">"%d{%m/%d/%y %H:%M:%S}  - %m [%l]%n"</span><span style="color: rgb(0, 0, 204);">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">std</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(255, 0, 0);">auto_ptr</span> _layout<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 255);">new</span> PatternLayout<span style="color: rgb(0, 0, 204);">(</span>pattern<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 3: Attach the layout object to the appender */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_append<span style="color: rgb(0, 0, 204);">-</span><span style="color: rgb(0, 0, 204);">&gt;</span>setLayout<span style="color: rgb(0, 0, 204);">(</span> _layout <span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 4: Instantiate a logger object */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;Logger _logger <span style="color: rgb(0, 0, 204);">=</span> Logger<span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span>getInstance<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(255, 0, 255);">"test"</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 5: Attach the appender object to the logger  */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_logger<span style="color: rgb(0, 0, 204);">.</span>addAppender<span style="color: rgb(0, 0, 204);">(</span>_append<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 6: Set a priority for the logger  */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_logger<span style="color: rgb(0, 0, 204);">.</span>setLogLevel<span style="color: rgb(0, 0, 204);">(</span>ALL_LOG_LEVEL<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* log activity */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;LOG4CPLUS_DEBUG<span style="color: rgb(0, 0, 204);">(</span>_logger<span style="color: rgb(0, 0, 204);">,</span> <span style="color: rgb(255, 0, 255);">"This is the FIRST log message..."</span><span style="color: rgb(0, 0, 204);">)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">sleep</span><span style="color: rgb(0, 0, 204);">(</span>1<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;LOG4CPLUS_WARN<span style="color: rgb(0, 0, 204);">(</span>_logger<span style="color: rgb(0, 0, 204);">,</span> <span style="color: rgb(255, 0, 255);">"This is the SECOND log message..."</span><span style="color: rgb(0, 0, 204);">)</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 255);">return</span> 0<span style="color: rgb(0, 0, 204);">;</span><br>
<span style="color: rgb(0, 0, 204);">}</span><br>
<br>
</span></code></p></td></tr></tbody></table><table style="border-collapse: collapse;" bgcolor="#f1f1f1" border="1" bordercolor="#999999" cellpadding="0" cellspacing="0" width="95%"><tbody><tr><td><p style="margin: 5px; line-height: 150%;"><code><span style="color: rgb(0, 0, 0);"><span style="color: rgb(255, 153, 0);">/*<br>
&nbsp;&nbsp;&nbsp;&nbsp;严格实现步骤1-6，appender输出到屏幕, 其中的布局格式和LogLevel后面会详细解释。<br>
*/</span><br>
<span style="color: rgb(0, 0, 204);">#</span><span style="color: rgb(255, 0, 0);">include</span> <span style="color: rgb(0, 0, 204);">&lt;</span>log4cplus<span style="color: rgb(0, 0, 204);">/</span>logger<span style="color: rgb(0, 0, 204);">.</span>h<span style="color: rgb(0, 0, 204);">&gt;</span><br>
<span style="color: rgb(0, 0, 204);">#</span><span style="color: rgb(255, 0, 0);">include</span> <span style="color: rgb(0, 0, 204);">&lt;</span>log4cplus<span style="color: rgb(0, 0, 204);">/</span>consoleappender<span style="color: rgb(0, 0, 204);">.</span>h<span style="color: rgb(0, 0, 204);">&gt;</span><br>
<span style="color: rgb(0, 0, 204);">#</span><span style="color: rgb(255, 0, 0);">include</span> <span style="color: rgb(0, 0, 204);">&lt;</span>log4cplus<span style="color: rgb(0, 0, 204);">/</span>layout<span style="color: rgb(0, 0, 204);">.</span>h<span style="color: rgb(0, 0, 204);">&gt;</span><br>
<br>
<span style="color: rgb(0, 0, 255);">using</span> <span style="color: rgb(0, 0, 255);">namespace</span> log4cplus<span style="color: rgb(0, 0, 204);">;</span><br>
<span style="color: rgb(0, 0, 255);">using</span> <span style="color: rgb(0, 0, 255);">namespace</span> log4cplus<span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span>helpers<span style="color: rgb(0, 0, 204);">;</span><br>
<br>
<span style="color: rgb(0, 0, 255);">int</span> main<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 204);">)</span><br>
<span style="color: rgb(0, 0, 204);">{</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 1: Instantiate an appender object */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;SharedObjectPtr _append <span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 255);">new</span> ConsoleAppender<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_append<span style="color: rgb(0, 0, 204);">-</span><span style="color: rgb(0, 0, 204);">&gt;</span>setName<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(255, 0, 255);">"append for test"</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 2: Instantiate a layout object */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">std</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(255, 0, 0);">string</span> pattern <span style="color: rgb(0, 0, 204);">=</span> <span style="color: rgb(255, 0, 255);">"%d{%m/%d/%y %H:%M:%S}  - %m [%l]%n"</span><span style="color: rgb(0, 0, 204);">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">std</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(255, 0, 0);">auto_ptr</span> _layout<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(0, 0, 255);">new</span> PatternLayout<span style="color: rgb(0, 0, 204);">(</span>pattern<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 3: Attach the layout object to the appender */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_append<span style="color: rgb(0, 0, 204);">-</span><span style="color: rgb(0, 0, 204);">&gt;</span>setLayout<span style="color: rgb(0, 0, 204);">(</span> _layout <span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 4: Instantiate a logger object */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;Logger _logger <span style="color: rgb(0, 0, 204);">=</span> Logger<span style="color: rgb(0, 0, 204);">:</span><span style="color: rgb(0, 0, 204);">:</span>getInstance<span style="color: rgb(0, 0, 204);">(</span><span style="color: rgb(255, 0, 255);">"test"</span><span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 5: Attach the appender object to the logger  */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_logger<span style="color: rgb(0, 0, 204);">.</span>addAppender<span style="color: rgb(0, 0, 204);">(</span>_append<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* step 6: Set a priority for the logger  */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;_logger<span style="color: rgb(0, 0, 204);">.</span>setLogLevel<span style="color: rgb(0, 0, 204);">(</span>ALL_LOG_LEVEL<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 153, 0);">/* log activity */</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;LOG4CPLUS_DEBUG<span style="color: rgb(0, 0, 204);">(</span>_logger<span style="color: rgb(0, 0, 204);">,</span> <span style="color: rgb(255, 0, 255);">"This is the FIRST log message..."</span><span style="color: rgb(0, 0, 204);">)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">sleep</span><span style="color: rgb(0, 0, 204);">(</span>1<span style="color: rgb(0, 0, 204);">)</span><span style="color: rgb(0, 0, 204);">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;LOG4CPLUS_WARN<span style="color: rgb(0, 0, 204);">(</span>_logger<span style="color: rgb(0, 0, 204);">,</span> <span style="color: rgb(255, 0, 255);">"This is the SECOND log message..."</span><span style="color: rgb(0, 0, 204);">)</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 255);">return</span> 0<span style="color: rgb(0, 0, 204);">;</span><br>
<span style="color: rgb(0, 0, 204);">}</span><br>
<br>
</span></code></p></td></tr></tbody></table>
</div>
</td></tr>
</table>

<p style="line-height: 150%; margin: 5px">
 
 
</p>
</td></tr>
<tr><td height="25">
&nbsp;<font color="#000099"><b>原文地址</b></font>
<a href="http://blog.chinaunix.net/u/24129/showart.php?id=1093943" target="_blank">http://blog.chinaunix.net/u/24129/showart.php?id=1093943</a>
</td></tr>
 
 
<tr><td height="25" align="center">
<font color="#295200">发表于： 2008-08-01 ，修改于： 2008-08-01 20:39，已浏览1049次，有评论1条</font>
<a href="/u2/star.php?blogid=19742&artid=1101073" id="star" onclick="NewWindows(this.href);return false;" title="推荐这篇文章">推荐</a>
<a href="/u2/complaint.php?blogid=19742&artid=1101073" id="complaint" onclick="NewWindows(this.href);return false;" title="投诉这篇文章">投诉</a>

</td></tr>


</table>


</td></tr>
</table>


</td><td width="18" background="../../templates/newgreen/images/bg_art_right.gif"></td></tr>


<tr><td width="18" height="28"><img src="../../templates/newgreen/images/bg_art_left_bottom.gif" border="0" alt="" /></td><td background="../../templates/newgreen/images/bg_art_bottom.gif"><p style="line-height: 150%; margin: 5px"></p></td><td width="18" height="28"><img src="../../templates/newgreen/images/bg_art_right_bottom.gif" border="0" alt="" /></td></tr>


</table>
<br />
<table border="1" cellspacing="1" cellpadding="0" style="border-collapse: collapse" bordercolor="#A5BD6B" width="90%" align="center">
<tr><td height="25" style="color:#295200" bgcolor="#EFF7DE"> <b>网友评论</b></td></tr>
<tr><td height="1" bgcolor="#FFFFFF"></td></tr>
<tr><td align="center" bgcolor="#F9F5E7">
<table border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse;color:#295200;word-wrap:break-word;" width="100%" align="center">
<tr><td width="60" valign="top"><b>内容：</b></td>
<td width="580" valign="top">

<pre style="line-height: 150%; margin: 0px;" wrap="break-word">
抄来抄去，有什么意思</pre>
</td>
</tr>
<tr height="25">
<td colspan="2" style="color:#737373;font-size:8pt">
本站网友评论于：2009-05-13 16:51:46  &#32;&#32; （124.42.13.★）
</td></tr>

<tr><td height="15" colspan="3"></td></tr>
<tr><td colspan="3"><img src="../../templates/newgreen/images/middle_line.gif"  border="0" alt="" /></td></tr>
</table>
</td></tr>
</table>
<br />


<table border="1" cellspacing="1" cellpadding="0" style="border-collapse: collapse" bordercolor="#A5BD6B" width="90%" align="center">
<tr><td height="25" style="color:#295200" bgcolor="#EFF7DE"> <b>发表评论</b></td></tr>
<tr><td height="1" bgcolor="#FFFFFF"></td></tr>
<tr><td align="center" bgcolor="#F9F5E7">
 
<IFRAME NAME="comment" SRC="/comment/comment.php?bg=F9F5E7&ctype=0&iscomment=1&artid=1101073&blogid=19742" WIDTH="100%" HEIGHT="160" frameborder="0"></IFRAME>
 

</td></tr>
</table>
